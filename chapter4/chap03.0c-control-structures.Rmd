--- 
title: "Data Science + Public Policy"
author: "Jeffrey Chen"
date: '`r Sys.Date()`'
output:
  html_document: default
  latex_engine: xelatex
  pdf_document: null
description: Manipulation - Control Structures - Etiquette
documentclass: book
link-citations: yes
bibliography:
- book.bib
- packages.bib
site: bookdown::bookdown_site
biblio-style: apalikex
---



## Control Structures
Much of data science requires developing specialized code to handle the eccentricities of a dataset. Re-running blocks of code is required, often times on multiple data samples and subpopulations. It is simply not scalable to manually change variables and assumptions of the code everytime. 

Variables are typically treated differently based on their quality and characteristics. In order to accomplish analytical and programming tasks, control structures are used to determine how a program will treat a given variable given conditions and parameters. In this section, we will cover two commonly used control structures: if...else statements and for loops.

### If and If...Else Statement
If statements evaluate a logical statement, then execute a script based on whether the evaluated statement is true or false. If the statement is `TRUE`, then the code block is executed.

```{r}
  budget <- 450
  if(budget > 400){
    #If statement true, run script goes here
    print("You're over budget. Cut back.")
  }
```

In cases where there are two or more choices, if...else statements would be appropriate. In addition to the `if()` statement, an `else` statement is included to handle cases where the logical statement is `FALSE`.


```{r, eval=FALSE}
  budget <- 399  
  if(budget >= 400){
    #If statement true, run script goes here
    print("You're over budget. Cut back.")
  } else {
    #else, run script goes here
    print("You're under budget, but watch it.")
  }
```

The complexity of these statements can be as simple as `if(x > 10){ print("Hello")}` more complex trees:

```{r}
  age <- 23
    
  if(age <= 12){
      print("kid")
    } else if(age >12 && age <20) {
      print("teenager")
    } else if(age >=20 && age <65) {
      print("adult")
    } else{
      print("senior")
    }
```


###For-loops
Loops can be used to run the a given statement of code multiple times for a specified number of times or a list of index value. This is a functionality that is available in most programming languages, but the programming syntax will be different. Conceptually, for loops can be likened to an assembly line in a car factory. In order to build a car, a series of well-defined, well-timed processes need to coordinated in a serial fashion. To build 500 cars, the process needs to be executed 500 times. For-loops are essentially the same: Given a well-defined, self-contained process, a process can be be iterativelyapplied to address repetive tasks.

Let's take the following example. The code block essentially says "print values for the range of 1 through 5", where `i` is an *index value*. When executing the statement, R will push the first value in the sequence of 1:5 into the index (in this case, it's the number 1), then the code block in between the `{}` (curly brackets) will be executed, treating `i` as if it's the number 1. Upon executing the code without error, R will advance to the next value in the sequence and repeat the process until all values in the sequence have been completed.

```{r}
  for(i in 1:5){
    print(paste0("Car #", i))
  }
```

We can do the same for a vector or list of values. In the example below, the vector `news` contains six terms. Using a for-loop, we can print out each word in the vector. 

```{r}
  news <- c("The","Dow","Is","Up","By","400pts")
  for(i in news){
    print(i)
  }
```

For-loops has a few qualities that users should be aware. First, what happens within the for-loop is written to the R environment as _global variables_. That means that any object (e.g. calculations, models) that is created in the loop will be accessible in the programming enviromment even after the loop ends. This may be a good or bad, depending on the use case: Good if one wants to keep copies of the intermediate results of a loop iteration, but bad if the user is not careful to take note of the potential floor of extraneous objects that may effect downstream calculations.  Second, one of the most common mistakes when using loops is failing to record the result of the loop. There are functions in R that are designed to log and package results from loops, but in plain vanilla loops, this is not the case. 

__A common paradigm__ with for-loops is to iteratively execute repetitive tasks. For example, if a calculation needed to be applied to each of one million files and the results need to be logged, then for-loops are a good option. Typically, the paradigm proceeds as follows:

1. Create placeholder object (e.g. a vector, matrix, or data frame);
2. Initialize loop; and
3. Add outputs to placeholder at the end of each loop iteration. 

This may be applied in a broad variety of cases such as processes each data set in a repository of many large data sets, calculating complex statistics for various strata and subsets within the data, among others. Best practices with loops start with initializing new placeholder objects to full length before the loop rather than increasing the object size within the loop^[https://www.r-project.org/doc/Rnews/Rnews_2008-1.pdf]. In R, this is particularly important issue for efficient data processing. 

In the example below, we would like to calculate the minimum and maximum of each of 1000 randomly generated normal distributions with $\mu = 1000$ and $\sigma = 10$. To do this, a placeholder data frame `x` with three columns (iteration, min and max) is created with $n = 1000$ rows for each of the random distributions to be generated. Then, we use `Sys.time()` to capture when the loop starts and end -- a common practice for optimizing code. The loop is initiated for 1 to 1000 iterations to calculate the mininum and maximum. At the end of each iteration, the min and max results are overwritten to the row that corresponds to the iteration in the placeholder `x`. 


```{r}
#Set placeholder data frame with n rows
  n <- 1000
  x <- data.frame(iteration = 1:n, 
                  min = numeric(n), 
                  max = numeric(n))

#Loop
  start <- Sys.time()
  for(i in 1:n){
    y <- rnorm(10000, 1000, 10)
    x$min[i] <- min(y)
    x$max[i] <- max(y)
  }
  Sys.time() - start

```

The above process required roughly 0.8 seconds to process. _What happens if the placeholder length were not pre-specified?_ For the given parameters, the task normally may last between 1.2 and 1.5 seconds. This may not seem to be much time, but at scale with millions if not billions of records and iterations, the time does tend to add up.

```{r}
#Set placeholder data frame without dimensions
  n <- 1000
  x <- data.frame()

#Loop
  start <- Sys.time()
  for(i in 1:n){
    set.seed(i)
    y <- rnorm(10000, 1000, 10)
    x <- rbind(x, cbind(iteration = i, 
                  min = min(y), 
                  max = max(y)))
  }
  Sys.time() - start

```


#### R-specific: `apply`

For-loops are common across all languages, but the efficiency of their implementation will vary. As was described in the previous chapter, R is an interpretted language optimized for mathematical and statistical calculation -- quite different than other languages. This means that programming in R is most optimal when vectorizing calculation -- linear algebra calculations of vectors and matrices using operations such as `+`, `-`, `*`, `%*%`, among others.

In R, the speed of for-loops may be improved using `lapply()` under certain circumstances.  `lapply()`, or _list apply_ Whereas the intermediate objects in for-loops are global variables, `lapply()` creates temporary _local variables_. 


```{r}
#Set n
  n <- 1000

#Loop
  start <- Sys.time()
  x <- lapply(1:n, function(i){
     y <- rnorm(10000, 1000, 10)
     return(cbind(iteration = i, 
                  min = min(y), 
                  max = max(y)))
  })
  x <- do.call(rbind, x)
  Sys.time() - start
```


###While
Whereas for loops require a range or list of values through which to iterate, `while()` statements keep iterating until some condition is met. The `while()` statement is formulated as follows:

```{r, eval=FALSE}
  while([condition is true]){
    
    [execute this statement]
    
  }
```

A simple case may involve drawing a random value $x$ from a normal distribution ($\mu = 1.0$, $\sigma = 0.5$) while $x$ is greater than 0.01. 
```{r, echo = FALSE}
set.seed(1)
```
```{r}
  x <- 1
  while(x > 0.01){
    x <- rnorm(1, 1, 0.5)
    print(x)
  }
  print("done!")
```


#### Exercises {-}
1. Write an if-else statement that classifies a number as positive number as "up" and a negative number as "down". Then, write a forloop to classify each record of `x` from `x_2` to `x_100` is up or down relative to the preceding record Then, use `table()` to tabular the number of up days versus down days. 

```{r}
  n <- 500
  series <- sin((1:n)/100) + cos((1:n)/80)

```

2. Fibonacci numbers are defined as $F_n = F_{n-1} + F_{n-2}$, or numbers that are defined as the sum of the preceding two numbers. For example, given an initial sequence of ```0, 1```, the next five numbers are ```1, 2, 3, 5, 8```. Using a `while()` loop, find the Fibonacci number that precedes 1,000,000.
3. Often times, data files are stored in smaller chunks to save space and enhance searchability. In some cases, data is stored in daily chunks. The National Oceanic and Atmospheric Administration (NOAA) releases data every day on environmental and atmospheric conditions, including storms. Download the data using `digIt("hail_201601", download = TRUE)` and unzip the files, then use `list.files()`, then write a loop to record the following measures in a data frame:

- month and year
- number of rows
- maximum hail size from the `maxsize` field

__Answers__

1. _If-Else Statement_.
```{r}
#define series 
  n <- 500
  series <- sin((1:n)/100) + cos((1:n)/80)
  
#write if-else for i = 2
  temp <- c()
  if(series[2] >= series[2-1]){
      temp <- c(temp, "up")
    } else{
      temp <- c(temp, "down")
    }
  
#set empty vector
  temp <- c()
  
#loop through if-statement
  for(i in 2:length(series)){
    if(series[i] >= series[i-1]){
      temp <- c(temp, "up")
    } else{
      temp <- c(temp, "down")
    }
  }
  table(temp)
```


2. _Fibonacci Sequence_.

```{r}
#define variables
  n <- 0
  n0 <- 0
  n1 <- 1
  f <- 0
  s <- c()

#enter into loop
  while(f < 1000000){
    f <- n0 + n1
    n0 <- n1
    n1 <- f
    n <- n + 1
    s <- c(s, f)
  }
  
#get result in the (n-1)th position 
  print(s[n-1])
  
```

3. _Hail files_.

```{r, eval = FALSE}
#Download the hail files to the current working directory
  library(digIt)
  digIt("hail_201601", download = TRUE)
  
#Unzip the zip file
  unzip("compressed.zip")

#Get all files that start with hail
  hail <- list.files(pattern = "^hail_\\d{6}")

#create empty dataframe
  temp <- data.frame()
  for(rec in hail){
    df <- read.csv(rec)
    maxhail <- max(df$MAXSIZE)
    date <- regmatches(rec,regexpr("\\d{6}", rec))
    rows <- nrow(df)
    temp <- rbind(temp, data.frame(max.hail = maxhail, date = date, rows = rows))
  }

  
```
